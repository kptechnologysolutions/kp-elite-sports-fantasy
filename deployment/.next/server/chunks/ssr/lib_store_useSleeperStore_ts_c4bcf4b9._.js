module.exports=[31686,a=>{"use strict";a.s(["default",()=>i],31686);var b=a.i(72131);let c=a=>{let b,c=new Set,d=(a,d)=>{let e="function"==typeof a?a(b):a;if(!Object.is(e,b)){let a=b;b=(null!=d?d:"object"!=typeof e||null===e)?e:Object.assign({},b,e),c.forEach(c=>c(b,a))}},e=()=>b,f={setState:d,getState:e,getInitialState:()=>g,subscribe:a=>(c.add(a),()=>c.delete(a))},g=b=a(d,e,f);return f},d=a=>{let d=(a=>a?c(a):c)(a),e=a=>(function(a,c=a=>a){let d=b.default.useSyncExternalStore(a.subscribe,b.default.useCallback(()=>c(a.getState()),[a,c]),b.default.useCallback(()=>c(a.getInitialState()),[a,c]));return b.default.useDebugValue(d),d})(d,a);return Object.assign(e,d),e},e=a=>b=>{try{let c=a(b);if(c instanceof Promise)return c;return{then:a=>e(a)(c),catch(a){return this}}}catch(a){return{then(a){return this},catch:b=>e(b)(a)}}},f="https://api.sleeper.app/v1";class g{playersCache=new Map;leagueUsersCache=new Map;async getUser(a){let b=await fetch(`${f}/user/${a}`);if(!b.ok)throw Error("User not found");return b.json()}async getUserLeagues(a,b="nfl",c){let d=c||new Date().getFullYear().toString(),e=await fetch(`${f}/user/${a}/leagues/${b}/${d}`);if(!e.ok)throw Error("Failed to fetch leagues");return e.json()}async getLeagueRosters(a){let b=await fetch(`${f}/league/${a}/rosters`);if(!b.ok)throw Error("Failed to fetch rosters");return b.json()}async getLeagueUsers(a){if(this.leagueUsersCache.has(a))return this.leagueUsersCache.get(a);let b=await fetch(`${f}/league/${a}/users`);if(!b.ok)throw Error("Failed to fetch league users");let c=await b.json(),d=new Map;return c.forEach(a=>{d.set(a.user_id,{...a,team_name:a.metadata?.team_name||a.display_name})}),this.leagueUsersCache.set(a,d),d}async getMatchups(a,b){let c=await fetch(`${f}/league/${a}/matchups/${b}`);if(!c.ok)throw Error("Failed to fetch matchups");return c.json()}async getSeasonMatchups(a,b){let c=new Map,d=[];for(let c=1;c<=b;c++)d.push(this.getMatchups(a,c).then(a=>({week:c,matchups:a})).catch(()=>({week:c,matchups:[]})));return(await Promise.all(d)).forEach(({week:a,matchups:b})=>{b.length>0&&c.set(a,b)}),c}async getNFLState(){let a=await fetch(`${f}/state/nfl`);if(!a.ok)throw Error("Failed to fetch NFL state");let b=await a.json();return{week:b.week||1,season:b.season||new Date().getFullYear().toString(),season_type:b.season_type||"regular"}}async getAllPlayers(){if(this.playersCache.size>0)return this.playersCache;try{let a=localStorage.getItem("sleeper_players_minimal"),b=localStorage.getItem("sleeper_players_timestamp");if(a&&b&&Date.now()-parseInt(b)<864e5&&(JSON.parse(a).forEach(a=>{this.playersCache.set(a.player_id,a)}),this.playersCache.size>0))return this.playersCache}catch(a){console.log("Cache load failed, fetching fresh data")}let a=await fetch(`${f}/players/nfl`);if(!a.ok)throw Error("Failed to fetch players");let b=await a.json(),c=[];Object.entries(b).forEach(([a,b])=>{if("Active"===b.status||b.team){let d={player_id:a,first_name:b.first_name||"",last_name:b.last_name||"",full_name:b.full_name||`${b.first_name} ${b.last_name}`,position:b.position||"N/A",team:b.team||null,number:b.number||null,status:b.status||"Active",injury_status:b.injury_status||null,injury_notes:b.injury_notes||null,age:b.age||null,years_exp:b.years_exp||0,college:b.college||null,fantasy_positions:b.fantasy_positions||[b.position],depth_chart_order:b.depth_chart_order||null,depth_chart_position:b.depth_chart_position||null};this.playersCache.set(a,d),["QB","RB","WR","TE","K","DEF"].includes(b.position)&&c.push(d)}});try{localStorage.setItem("sleeper_players_minimal",JSON.stringify(c)),localStorage.setItem("sleeper_players_timestamp",Date.now().toString())}catch(a){console.warn("Could not cache player data due to quota");try{localStorage.removeItem("sleeper_players_data"),localStorage.removeItem("sleeper_players"),localStorage.setItem("sleeper_players_minimal",JSON.stringify(c)),localStorage.setItem("sleeper_players_timestamp",Date.now().toString())}catch(a){console.warn("Storage quota exceeded, using memory cache only")}}return this.playersCache}async getPlayer(a){return(await this.getAllPlayers()).get(a)}async getTransactions(a,b){let c=await fetch(`${f}/league/${a}/transactions/${b}`);if(!c.ok)throw Error("Failed to fetch transactions");return c.json()}async getTrendingPlayers(a="nfl",b="add",c=25){let d=await fetch(`${f}/players/${a}/trending/${b}?limit=${c}`);if(!d.ok)throw Error("Failed to fetch trending players");return d.json()}async getEnrichedRoster(a,b){let[c,d,e]=await Promise.all([this.getLeagueRosters(a),this.getLeagueUsers(a),this.getAllPlayers()]),f=c.find(a=>a.roster_id===b);if(!f)throw Error("Roster not found");let g=f.owner_id?d.get(f.owner_id):void 0,h=f.players.map(a=>e.get(a));return{roster:f,owner:g,players:h}}calculateOptimalLineup(a,b,c){let d={};a.forEach(a=>{if(!a)return;let c=b[a.player_id]||0;a.fantasy_positions?.forEach(b=>{d[b]||(d[b]=[]),d[b].push({player:a,points:c})})}),Object.keys(d).forEach(a=>{d[a].sort((a,b)=>b.points-a.points)});let e=[],f=new Set;return c.forEach(a=>{if("FLEX"===a){let a=[...d.RB||[],...d.WR||[],...d.TE||[]].filter(a=>!f.has(a.player.player_id)).sort((a,b)=>b.points-a.points);a[0]&&(e.push(a[0].player.player_id),f.add(a[0].player.player_id))}else if("SUPER_FLEX"===a){let a=[...d.QB||[],...d.RB||[],...d.WR||[],...d.TE||[]].filter(a=>!f.has(a.player.player_id)).sort((a,b)=>b.points-a.points);a[0]&&(e.push(a[0].player.player_id),f.add(a[0].player.player_id))}else{let b=(d[a]||[]).filter(a=>!f.has(a.player.player_id));b[0]&&(e.push(b[0].player.player_id),f.add(b[0].player.player_id))}}),e}}let h=new g,i=d(((a,b)=>(c,d,f)=>{let g,h={storage:function(a,b){let c;try{c=a()}catch(a){return}return{getItem:a=>{var b;let d=a=>null===a?null:JSON.parse(a,void 0),e=null!=(b=c.getItem(a))?b:null;return e instanceof Promise?e.then(d):d(e)},setItem:(a,b)=>c.setItem(a,JSON.stringify(b,void 0)),removeItem:a=>c.removeItem(a)}}(()=>localStorage),partialize:a=>a,version:0,merge:(a,b)=>({...b,...a}),...b},i=!1,j=new Set,k=new Set,l=h.storage;if(!l)return a((...a)=>{console.warn(`[zustand persist middleware] Unable to update item '${h.name}', the given storage is currently unavailable.`),c(...a)},d,f);let m=()=>{let a=h.partialize({...d()});return l.setItem(h.name,{state:a,version:h.version})},n=f.setState;f.setState=(a,b)=>(n(a,b),m());let o=a((...a)=>(c(...a),m()),d,f);f.getInitialState=()=>o;let p=()=>{var a,b;if(!l)return;i=!1,j.forEach(a=>{var b;return a(null!=(b=d())?b:o)});let f=(null==(b=h.onRehydrateStorage)?void 0:b.call(h,null!=(a=d())?a:o))||void 0;return e(l.getItem.bind(l))(h.name).then(a=>{if(a)if("number"!=typeof a.version||a.version===h.version)return[!1,a.state];else{if(h.migrate){let b=h.migrate(a.state,a.version);return b instanceof Promise?b.then(a=>[!0,a]):[!0,b]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}return[!1,void 0]}).then(a=>{var b;let[e,f]=a;if(c(g=h.merge(f,null!=(b=d())?b:o),!0),e)return m()}).then(()=>{null==f||f(g,void 0),g=d(),i=!0,k.forEach(a=>a(g))}).catch(a=>{null==f||f(void 0,a)})};return f.persist={setOptions:a=>{h={...h,...a},a.storage&&(l=a.storage)},clearStorage:()=>{null==l||l.removeItem(h.name)},getOptions:()=>h,rehydrate:()=>p(),hasHydrated:()=>i,onHydrate:a=>(j.add(a),()=>{j.delete(a)}),onFinishHydration:a=>(k.add(a),()=>{k.delete(a)})},h.skipHydration||p(),g||o})((a,b)=>({user:null,leagues:[],currentLeague:null,rosters:[],leagueUsers:new Map,myRoster:null,players:new Map,currentMatchups:[],currentWeek:1,seasonMatchups:new Map,isLoading:!1,error:null,setUser:b=>a({user:b}),setCurrentLeague:b=>a({currentLeague:b}),getPlayer:a=>b().players.get(a),login:async c=>{a({user:null,leagues:[],currentLeague:null,rosters:[],leagueUsers:new Map,myRoster:null,players:new Map,currentMatchups:[],currentWeek:1,seasonMatchups:new Map,isLoading:!0,error:null});try{console.log("Store: Getting user for",c);let d=await h.getUser(c);console.log("Store: User found:",d.display_name),a({user:d}),console.log("Store: Getting leagues...");let e=await h.getUserLeagues(d.user_id);console.log("Store: Found leagues:",e.length),a({leagues:e}),1===e.length?(console.log("Store: Auto-selecting single league:",e[0].name),await b().selectLeague(e[0].league_id)):console.log("Store: Multiple leagues found, user needs to select"),console.log("Store: Fetching players in background..."),b().fetchPlayers()}catch(b){throw console.error("Store: Login error:",b),a({error:b.message}),b}finally{a({isLoading:!1})}},fetchLeagues:async()=>{let{user:c}=b();if(c)try{let b=await h.getUserLeagues(c.user_id);a({leagues:b})}catch(b){a({error:b.message})}},selectLeague:async c=>{let{user:d,leagues:e}=b();if(d){console.log("Store: Selecting league:",c),a({isLoading:!0,error:null});try{let b=e.find(a=>a.league_id===c);if(!b)throw Error("League not found");console.log("Store: Found league:",b.name),a({currentLeague:b}),console.log("Store: Getting NFL state...");let f=await h.getNFLState();a({currentWeek:f.week}),console.log("Store: Fetching league data...");let[g,i,j,k]=await Promise.all([h.getLeagueRosters(c),h.getLeagueUsers(c),h.getMatchups(c,f.week),h.getSeasonMatchups(c,f.week)]),l=g.find(a=>a.owner_id===d.user_id)||null;console.log("Store: Found user roster:",l?"Yes":"No"),a({rosters:g,leagueUsers:i,myRoster:l,currentMatchups:j,seasonMatchups:k}),console.log("Store: League selection complete")}catch(b){console.error("Store: League selection error:",b),a({error:b.message})}finally{a({isLoading:!1})}}},fetchMatchups:async c=>{let{currentLeague:d,currentWeek:e}=b();if(!d)return;let f=c||e;try{let b=await h.getMatchups(d.league_id,f);a({currentMatchups:b,currentWeek:f})}catch(b){a({error:b.message})}},fetchPlayers:async()=>{try{let b=await h.getAllPlayers();a({players:b})}catch(a){console.error("Failed to fetch players:",a)}},refreshData:async()=>{let{currentLeague:c,currentWeek:d}=b();if(c){a({isLoading:!0});try{await Promise.all([b().selectLeague(c.league_id),b().fetchPlayers()])}catch(b){a({error:b.message})}finally{a({isLoading:!1})}}},optimizeLineup:()=>{let{myRoster:a,currentLeague:c,players:d,currentMatchups:e}=b();if(!a||!c)return[];let f=e.find(b=>b.roster_id===a.roster_id),g=f?.players_points||{},i=a.players.map(a=>d.get(a)).filter(Boolean);return h.calculateOptimalLineup(i,g,c.roster_positions)},logout:()=>{a({user:null,leagues:[],currentLeague:null,rosters:[],leagueUsers:new Map,myRoster:null,currentMatchups:[],currentWeek:1,isLoading:!1,error:null})}}),{name:"sleeper-store",partialize:a=>({user:a.user,currentLeague:a.currentLeague,currentWeek:a.currentWeek})}))}];

//# sourceMappingURL=lib_store_useSleeperStore_ts_c4bcf4b9._.js.map