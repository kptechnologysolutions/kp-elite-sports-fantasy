{"version":3,"sources":["turbopack:///[project]/node_modules/zustand/esm/react.mjs","turbopack:///[project]/node_modules/zustand/esm/vanilla.mjs","turbopack:///[project]/node_modules/zustand/esm/middleware.mjs","turbopack:///[project]/lib/services/sleeperService.ts","turbopack:///[project]/lib/store/useSleeperStore.ts"],"sourcesContent":["import React from 'react';\nimport { createStore } from 'zustand/vanilla';\n\nconst identity = (arg) => arg;\nfunction useStore(api, selector = identity) {\n  const slice = React.useSyncExternalStore(\n    api.subscribe,\n    React.useCallback(() => selector(api.getState()), [api, selector]),\n    React.useCallback(() => selector(api.getInitialState()), [api, selector])\n  );\n  React.useDebugValue(slice);\n  return slice;\n}\nconst createImpl = (createState) => {\n  const api = createStore(createState);\n  const useBoundStore = (selector) => useStore(api, selector);\n  Object.assign(useBoundStore, api);\n  return useBoundStore;\n};\nconst create = ((createState) => createState ? createImpl(createState) : createImpl);\n\nexport { create, useStore };\n","const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const api = { setState, getState, getInitialState, subscribe };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = ((createState) => createState ? createStoreImpl(createState) : createStoreImpl);\n\nexport { createStore };\n","const reduxImpl = (reducer, initial) => (set, _get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return { dispatch: (...args) => api.dispatch(...args), ...initial };\n};\nconst redux = reduxImpl;\n\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api) return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nconst extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === void 0) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nconst removeStoreFromTrackedConnections = (name, store) => {\n  if (store === void 0) return;\n  const connectionInfo = trackedConnections.get(name);\n  if (!connectionInfo) return;\n  delete connectionInfo.stores[store];\n  if (Object.keys(connectionInfo.stores).length === 0) {\n    trackedConnections.delete(name);\n  }\n};\nconst findCallerName = (stack) => {\n  var _a, _b;\n  if (!stack) return void 0;\n  const traceLines = stack.split(\"\\n\");\n  const apiSetStateLineIndex = traceLines.findIndex(\n    (traceLine) => traceLine.includes(\"api.setState\")\n  );\n  if (apiSetStateLineIndex < 0) return void 0;\n  const callerLine = ((_a = traceLines[apiSetStateLineIndex + 1]) == null ? void 0 : _a.trim()) || \"\";\n  return (_b = /.+ (.+) .+/.exec(callerLine)) == null ? void 0 : _b[1];\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e) {\n  }\n  if (!extensionConnector) {\n    return fn(set, get, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = ((state, replace, nameOrAction) => {\n    const r = set(state, replace);\n    if (!isRecording) return r;\n    const action = nameOrAction === void 0 ? {\n      type: anonymousActionType || findCallerName(new Error().stack) || \"anonymous\"\n    } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === void 0) {\n      connection == null ? void 0 : connection.send(action, get());\n      return r;\n    }\n    connection == null ? void 0 : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r;\n  });\n  api.devtools = {\n    cleanup: () => {\n      if (connection && typeof connection.unsubscribe === \"function\") {\n        connection.unsubscribe();\n      }\n      removeStoreFromTrackedConnections(options.name, store);\n    }\n  };\n  const setStateFromDevtools = (...a) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set(...a);\n    isRecording = originalIsRecording;\n  };\n  const initialState = fn(api.setState, get, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? void 0 : connection.init(initialState);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? void 0 : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && args[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...args);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === void 0) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format.\n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === void 0 || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools) return;\n            if (typeof api.dispatch !== \"function\") return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState);\n            if (store === void 0) {\n              return connection == null ? void 0 : connection.init(api.getState());\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === void 0) {\n              connection == null ? void 0 : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                connection == null ? void 0 : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;\n            if (!lastComputedState) return;\n            if (store === void 0) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? void 0 : connection.send(\n              null,\n              // FIXME no-any\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState;\n};\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, fn) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e\n    );\n  }\n  if (parsed !== void 0) fn(parsed);\n};\n\nconst subscribeWithSelectorImpl = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = ((selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? void 0 : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  });\n  const initialState = fn(set, get, api);\n  return initialState;\n};\nconst subscribeWithSelector = subscribeWithSelectorImpl;\n\nfunction combine(initialState, create) {\n  return (...args) => Object.assign({}, initialState, create(...args));\n}\n\nfunction createJSONStorage(getStorage, options) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (e) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2, options == null ? void 0 : options.reviver);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(name, JSON.stringify(newValue, options == null ? void 0 : options.replacer)),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst persistImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    return setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      return setItem();\n    },\n    get,\n    api\n  );\n  api.getInitialState = () => configResult;\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a, _b;\n    if (!storage) return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => {\n      var _a2;\n      return cb((_a2 = get()) != null ? _a2 : configResult);\n    });\n    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            const migration = options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n            if (migration instanceof Promise) {\n              return migration.then((result) => [true, result]);\n            }\n            return [true, migration];\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return [false, deserializedStorageValue.state];\n        }\n      }\n      return [false, void 0];\n    }).then((migrationResult) => {\n      var _a2;\n      const [migrated, migratedState] = migrationResult;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      if (migrated) {\n        return setItem();\n      }\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      stateFromStorage = get();\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  if (!options.skipHydration) {\n    hydrate();\n  }\n  return stateFromStorage || configResult;\n};\nconst persist = persistImpl;\n\nexport { combine, createJSONStorage, devtools, persist, redux, subscribeWithSelector };\n","// Comprehensive Sleeper API Service\nconst SLEEPER_BASE_URL = 'https://api.sleeper.app/v1';\n\nexport interface SleeperUser {\n  user_id: string;\n  username: string;\n  display_name: string;\n  avatar: string;\n}\n\nexport interface SleeperLeague {\n  league_id: string;\n  name: string;\n  season: string;\n  season_type: string;\n  status: string;\n  sport: string;\n  settings: {\n    playoff_week_start: number;\n    leg: number;\n    max_keepers: number;\n    draft_rounds: number;\n    trade_deadline: number;\n    reserve_slots: number;\n    bench_slots: number;\n    waiver_budget: number;\n    [key: string]: any;\n  };\n  scoring_settings: { [key: string]: number };\n  roster_positions: string[];\n  total_rosters: number;\n}\n\nexport interface SleeperRoster {\n  roster_id: number;\n  owner_id: string;\n  league_id: string;\n  players: string[];\n  starters: string[];\n  reserve: string[];\n  taxi: string[];\n  settings: {\n    wins: number;\n    losses: number;\n    ties: number;\n    total_moves: number;\n    waiver_position: number;\n    waiver_budget_used: number;\n    fpts: number;\n    fpts_decimal?: number;\n    fpts_against: number;\n    fpts_against_decimal?: number;\n  };\n  metadata?: {\n    streak?: string;\n    record?: string;\n  };\n}\n\nexport interface SleeperMatchup {\n  roster_id: number;\n  matchup_id: number;\n  points: number;\n  custom_points: number | null;\n  players: string[];\n  starters: string[];\n  players_points: { [playerId: string]: number };\n  starters_points: number[];\n}\n\nexport interface SleeperPlayer {\n  player_id: string;\n  first_name: string;\n  last_name: string;\n  full_name: string;\n  position: string;\n  team: string | null;\n  number: number | null;\n  status: string;\n  injury_status: string | null;\n  injury_notes: string | null;\n  age: number | null;\n  years_exp: number;\n  college: string | null;\n  fantasy_positions: string[];\n  depth_chart_order: number | null;\n  depth_chart_position: string | null;\n}\n\nexport interface SleeperTransaction {\n  transaction_id: string;\n  type: string; // 'trade', 'waiver', 'free_agent'\n  status: string;\n  leg: number;\n  adds: { [playerId: string]: number }; // playerId -> rosterId\n  drops: { [playerId: string]: number };\n  roster_ids: number[];\n  waiver_budget: number[];\n  created: number; // timestamp\n}\n\nexport interface LeagueUser {\n  user_id: string;\n  display_name: string;\n  team_name?: string;\n  avatar?: string;\n  metadata?: {\n    team_name?: string;\n  };\n}\n\nclass SleeperService {\n  private playersCache: Map<string, SleeperPlayer> = new Map();\n  private leagueUsersCache: Map<string, Map<string, LeagueUser>> = new Map();\n  \n  // Get user by username\n  async getUser(username: string): Promise<SleeperUser> {\n    const response = await fetch(`${SLEEPER_BASE_URL}/user/${username}`);\n    if (!response.ok) throw new Error('User not found');\n    return response.json();\n  }\n  \n  // Get user's leagues for current season\n  async getUserLeagues(userId: string, sport = 'nfl', season?: string): Promise<SleeperLeague[]> {\n    const year = season || new Date().getFullYear().toString();\n    const response = await fetch(`${SLEEPER_BASE_URL}/user/${userId}/leagues/${sport}/${year}`);\n    if (!response.ok) throw new Error('Failed to fetch leagues');\n    return response.json();\n  }\n  \n  // Get all rosters in a league\n  async getLeagueRosters(leagueId: string): Promise<SleeperRoster[]> {\n    const response = await fetch(`${SLEEPER_BASE_URL}/league/${leagueId}/rosters`);\n    if (!response.ok) throw new Error('Failed to fetch rosters');\n    return response.json();\n  }\n  \n  // Get all users in a league (for display names)\n  async getLeagueUsers(leagueId: string): Promise<Map<string, LeagueUser>> {\n    // Check cache first\n    if (this.leagueUsersCache.has(leagueId)) {\n      return this.leagueUsersCache.get(leagueId)!;\n    }\n    \n    const response = await fetch(`${SLEEPER_BASE_URL}/league/${leagueId}/users`);\n    if (!response.ok) throw new Error('Failed to fetch league users');\n    \n    const users: LeagueUser[] = await response.json();\n    const userMap = new Map<string, LeagueUser>();\n    \n    users.forEach(user => {\n      userMap.set(user.user_id, {\n        ...user,\n        team_name: user.metadata?.team_name || user.display_name\n      });\n    });\n    \n    this.leagueUsersCache.set(leagueId, userMap);\n    return userMap;\n  }\n  \n  // Get matchups for a specific week\n  async getMatchups(leagueId: string, week: number): Promise<SleeperMatchup[]> {\n    const response = await fetch(`${SLEEPER_BASE_URL}/league/${leagueId}/matchups/${week}`);\n    if (!response.ok) throw new Error('Failed to fetch matchups');\n    return response.json();\n  }\n  \n  // Get all matchups for season (for calculating form)\n  async getSeasonMatchups(leagueId: string, endWeek: number): Promise<Map<number, SleeperMatchup[]>> {\n    const matchupsByWeek = new Map<number, SleeperMatchup[]>();\n    \n    // Fetch matchups for all weeks up to current\n    const promises = [];\n    for (let week = 1; week <= endWeek; week++) {\n      promises.push(\n        this.getMatchups(leagueId, week)\n          .then(matchups => ({ week, matchups }))\n          .catch(() => ({ week, matchups: [] })) // Handle weeks that haven't happened yet\n      );\n    }\n    \n    const results = await Promise.all(promises);\n    results.forEach(({ week, matchups }) => {\n      if (matchups.length > 0) {\n        matchupsByWeek.set(week, matchups);\n      }\n    });\n    \n    return matchupsByWeek;\n  }\n  \n  // Get current NFL state\n  async getNFLState(): Promise<{ week: number; season: string; season_type: string }> {\n    const response = await fetch(`${SLEEPER_BASE_URL}/state/nfl`);\n    if (!response.ok) throw new Error('Failed to fetch NFL state');\n    const state = await response.json();\n    return {\n      week: state.week || 1,\n      season: state.season || new Date().getFullYear().toString(),\n      season_type: state.season_type || 'regular'\n    };\n  }\n  \n  // Get all NFL players (cached)\n  async getAllPlayers(): Promise<Map<string, SleeperPlayer>> {\n    // Return cache if available and recent\n    if (this.playersCache.size > 0) {\n      return this.playersCache;\n    }\n    \n    // Try to load from localStorage first (might be partial due to quota)\n    try {\n      const cached = localStorage.getItem('sleeper_players_minimal');\n      const cacheTime = localStorage.getItem('sleeper_players_timestamp');\n      \n      if (cached && cacheTime) {\n        const age = Date.now() - parseInt(cacheTime);\n        // Use cache if less than 24 hours old\n        if (age < 24 * 60 * 60 * 1000) {\n          const players = JSON.parse(cached);\n          players.forEach((player: any) => {\n            this.playersCache.set(player.player_id, player);\n          });\n          if (this.playersCache.size > 0) {\n            return this.playersCache;\n          }\n        }\n      }\n    } catch (e) {\n      console.log('Cache load failed, fetching fresh data');\n    }\n    \n    // Fetch fresh data\n    const response = await fetch(`${SLEEPER_BASE_URL}/players/nfl`);\n    if (!response.ok) throw new Error('Failed to fetch players');\n    \n    const players = await response.json();\n    \n    // Convert to Map and create minimal dataset for storage\n    const minimalPlayers: SleeperPlayer[] = [];\n    \n    Object.entries(players).forEach(([id, player]: [string, any]) => {\n      // Only store active/relevant players to save space\n      if (player.status === 'Active' || player.team) {\n        const minimalPlayer: SleeperPlayer = {\n          player_id: id,\n          first_name: player.first_name || '',\n          last_name: player.last_name || '',\n          full_name: player.full_name || `${player.first_name} ${player.last_name}`,\n          position: player.position || 'N/A',\n          team: player.team || null,\n          number: player.number || null,\n          status: player.status || 'Active',\n          injury_status: player.injury_status || null,\n          injury_notes: player.injury_notes || null,\n          age: player.age || null,\n          years_exp: player.years_exp || 0,\n          college: player.college || null,\n          fantasy_positions: player.fantasy_positions || [player.position],\n          depth_chart_order: player.depth_chart_order || null,\n          depth_chart_position: player.depth_chart_position || null\n        };\n        \n        this.playersCache.set(id, minimalPlayer);\n        \n        // Only store if it's a relevant fantasy player\n        if (['QB', 'RB', 'WR', 'TE', 'K', 'DEF'].includes(player.position)) {\n          minimalPlayers.push(minimalPlayer);\n        }\n      }\n    });\n    \n    // Try to cache minimal data (much smaller)\n    try {\n      localStorage.setItem('sleeper_players_minimal', JSON.stringify(minimalPlayers));\n      localStorage.setItem('sleeper_players_timestamp', Date.now().toString());\n    } catch (e) {\n      console.warn('Could not cache player data due to quota');\n      // Clear old data to make room\n      try {\n        localStorage.removeItem('sleeper_players_data');\n        localStorage.removeItem('sleeper_players');\n        localStorage.setItem('sleeper_players_minimal', JSON.stringify(minimalPlayers));\n        localStorage.setItem('sleeper_players_timestamp', Date.now().toString());\n      } catch (e2) {\n        console.warn('Storage quota exceeded, using memory cache only');\n      }\n    }\n    \n    return this.playersCache;\n  }\n  \n  // Get single player\n  async getPlayer(playerId: string): Promise<SleeperPlayer | undefined> {\n    const players = await this.getAllPlayers();\n    return players.get(playerId);\n  }\n  \n  // Get transactions for a league\n  async getTransactions(leagueId: string, week: number): Promise<SleeperTransaction[]> {\n    const response = await fetch(`${SLEEPER_BASE_URL}/league/${leagueId}/transactions/${week}`);\n    if (!response.ok) throw new Error('Failed to fetch transactions');\n    return response.json();\n  }\n  \n  // Get trending players (adds/drops)\n  async getTrendingPlayers(sport = 'nfl', type: 'add' | 'drop' = 'add', limit = 25): Promise<any[]> {\n    const response = await fetch(`${SLEEPER_BASE_URL}/players/${sport}/trending/${type}?limit=${limit}`);\n    if (!response.ok) throw new Error('Failed to fetch trending players');\n    return response.json();\n  }\n  \n  // Helper: Get roster with enriched data\n  async getEnrichedRoster(leagueId: string, rosterId: number): Promise<{\n    roster: SleeperRoster;\n    owner: LeagueUser | undefined;\n    players: (SleeperPlayer | undefined)[];\n  }> {\n    const [rosters, users, playerMap] = await Promise.all([\n      this.getLeagueRosters(leagueId),\n      this.getLeagueUsers(leagueId),\n      this.getAllPlayers()\n    ]);\n    \n    const roster = rosters.find(r => r.roster_id === rosterId);\n    if (!roster) throw new Error('Roster not found');\n    \n    const owner = roster.owner_id ? users.get(roster.owner_id) : undefined;\n    const players = roster.players.map(playerId => playerMap.get(playerId));\n    \n    return { roster, owner, players };\n  }\n  \n  // Helper: Calculate optimal lineup\n  calculateOptimalLineup(\n    players: SleeperPlayer[],\n    playerPoints: { [playerId: string]: number },\n    rosterPositions: string[]\n  ): string[] {\n    // Group players by position\n    const byPosition: { [pos: string]: Array<{ player: SleeperPlayer; points: number }> } = {};\n    \n    players.forEach(player => {\n      if (!player) return;\n      const points = playerPoints[player.player_id] || 0;\n      \n      player.fantasy_positions?.forEach(pos => {\n        if (!byPosition[pos]) byPosition[pos] = [];\n        byPosition[pos].push({ player, points });\n      });\n    });\n    \n    // Sort each position by points\n    Object.keys(byPosition).forEach(pos => {\n      byPosition[pos].sort((a, b) => b.points - a.points);\n    });\n    \n    const lineup: string[] = [];\n    const used = new Set<string>();\n    \n    // Fill roster positions\n    rosterPositions.forEach(pos => {\n      if (pos === 'FLEX') {\n        // FLEX can be RB, WR, or TE\n        const flexCandidates = [\n          ...(byPosition['RB'] || []),\n          ...(byPosition['WR'] || []),\n          ...(byPosition['TE'] || [])\n        ]\n          .filter(p => !used.has(p.player.player_id))\n          .sort((a, b) => b.points - a.points);\n        \n        if (flexCandidates[0]) {\n          lineup.push(flexCandidates[0].player.player_id);\n          used.add(flexCandidates[0].player.player_id);\n        }\n      } else if (pos === 'SUPER_FLEX') {\n        // SUPER_FLEX can be any offensive player\n        const superFlexCandidates = [\n          ...(byPosition['QB'] || []),\n          ...(byPosition['RB'] || []),\n          ...(byPosition['WR'] || []),\n          ...(byPosition['TE'] || [])\n        ]\n          .filter(p => !used.has(p.player.player_id))\n          .sort((a, b) => b.points - a.points);\n        \n        if (superFlexCandidates[0]) {\n          lineup.push(superFlexCandidates[0].player.player_id);\n          used.add(superFlexCandidates[0].player.player_id);\n        }\n      } else {\n        // Regular position\n        const candidates = (byPosition[pos] || [])\n          .filter(p => !used.has(p.player.player_id));\n        \n        if (candidates[0]) {\n          lineup.push(candidates[0].player.player_id);\n          used.add(candidates[0].player.player_id);\n        }\n      }\n    });\n    \n    return lineup;\n  }\n}\n\nexport const sleeperService = new SleeperService();","'use client';\n\nimport { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nimport { \n  sleeperService, \n  SleeperUser, \n  SleeperLeague, \n  SleeperRoster, \n  SleeperPlayer,\n  SleeperMatchup,\n  LeagueUser\n} from '@/lib/services/sleeperService';\n\ninterface SleeperStore {\n  // User data\n  user: SleeperUser | null;\n  setUser: (user: SleeperUser | null) => void;\n  \n  // Leagues\n  leagues: SleeperLeague[];\n  currentLeague: SleeperLeague | null;\n  setCurrentLeague: (league: SleeperLeague | null) => void;\n  \n  // Rosters & Users\n  rosters: SleeperRoster[];\n  leagueUsers: Map<string, LeagueUser>;\n  myRoster: SleeperRoster | null;\n  \n  // Players\n  players: Map<string, SleeperPlayer>;\n  getPlayer: (playerId: string) => SleeperPlayer | undefined;\n  \n  // Matchups\n  currentMatchups: SleeperMatchup[];\n  currentWeek: number;\n  seasonMatchups: Map<number, SleeperMatchup[]>;\n  \n  // Loading states\n  isLoading: boolean;\n  error: string | null;\n  \n  // Actions\n  login: (username: string) => Promise<void>;\n  fetchLeagues: () => Promise<void>;\n  selectLeague: (leagueId: string) => Promise<void>;\n  fetchMatchups: (week?: number) => Promise<void>;\n  fetchPlayers: () => Promise<void>;\n  refreshData: () => Promise<void>;\n  logout: () => void;\n  optimizeLineup: () => string[];\n}\n\nconst useSleeperStore = create<SleeperStore>()(\n  persist(\n    (set, get) => ({\n      // Initial state\n      user: null,\n      leagues: [],\n      currentLeague: null,\n      rosters: [],\n      leagueUsers: new Map(),\n      myRoster: null,\n      players: new Map(),\n      currentMatchups: [],\n      currentWeek: 1,\n      seasonMatchups: new Map(),\n      isLoading: false,\n      error: null,\n      \n      // User actions\n      setUser: (user) => set({ user }),\n      \n      // League actions\n      setCurrentLeague: (league) => set({ currentLeague: league }),\n      \n      // Player actions\n      getPlayer: (playerId) => get().players.get(playerId),\n      \n      // Login and fetch initial data\n      login: async (username) => {\n        // Clear all existing data first\n        set({\n          user: null,\n          leagues: [],\n          currentLeague: null,\n          rosters: [],\n          leagueUsers: new Map(),\n          myRoster: null,\n          players: new Map(),\n          currentMatchups: [],\n          currentWeek: 1,\n          seasonMatchups: new Map(),\n          isLoading: true,\n          error: null\n        });\n        \n        try {\n          console.log('Store: Getting user for', username);\n          // Get user\n          const user = await sleeperService.getUser(username);\n          console.log('Store: User found:', user.display_name);\n          set({ user });\n          \n          // Get leagues\n          console.log('Store: Getting leagues...');\n          const leagues = await sleeperService.getUserLeagues(user.user_id);\n          console.log('Store: Found leagues:', leagues.length);\n          set({ leagues });\n          \n          // Auto-select first league if only one\n          if (leagues.length === 1) {\n            console.log('Store: Auto-selecting single league:', leagues[0].name);\n            await get().selectLeague(leagues[0].league_id);\n          } else {\n            console.log('Store: Multiple leagues found, user needs to select');\n          }\n          \n          // Fetch players in background\n          console.log('Store: Fetching players in background...');\n          get().fetchPlayers();\n        } catch (error: any) {\n          console.error('Store: Login error:', error);\n          set({ error: error.message });\n          throw error;\n        } finally {\n          set({ isLoading: false });\n        }\n      },\n      \n      // Fetch user's leagues\n      fetchLeagues: async () => {\n        const { user } = get();\n        if (!user) return;\n        \n        try {\n          const leagues = await sleeperService.getUserLeagues(user.user_id);\n          set({ leagues });\n        } catch (error: any) {\n          set({ error: error.message });\n        }\n      },\n      \n      // Select and load league data\n      selectLeague: async (leagueId) => {\n        const { user, leagues } = get();\n        if (!user) return;\n        \n        console.log('Store: Selecting league:', leagueId);\n        set({ isLoading: true, error: null });\n        \n        try {\n          // Find league\n          const league = leagues.find(l => l.league_id === leagueId);\n          if (!league) throw new Error('League not found');\n          \n          console.log('Store: Found league:', league.name);\n          set({ currentLeague: league });\n          \n          // Get NFL state for current week\n          console.log('Store: Getting NFL state...');\n          const nflState = await sleeperService.getNFLState();\n          set({ currentWeek: nflState.week });\n          \n          // Fetch all league data in parallel\n          console.log('Store: Fetching league data...');\n          const [rosters, leagueUsers, matchups, seasonMatchups] = await Promise.all([\n            sleeperService.getLeagueRosters(leagueId),\n            sleeperService.getLeagueUsers(leagueId),\n            sleeperService.getMatchups(leagueId, nflState.week),\n            sleeperService.getSeasonMatchups(leagueId, nflState.week)\n          ]);\n          \n          // Find user's roster\n          const myRoster = rosters.find(r => r.owner_id === user.user_id) || null;\n          console.log('Store: Found user roster:', myRoster ? 'Yes' : 'No');\n          \n          set({ \n            rosters,\n            leagueUsers,\n            myRoster,\n            currentMatchups: matchups,\n            seasonMatchups\n          });\n          console.log('Store: League selection complete');\n        } catch (error: any) {\n          console.error('Store: League selection error:', error);\n          set({ error: error.message });\n        } finally {\n          set({ isLoading: false });\n        }\n      },\n      \n      // Fetch matchups for specific week\n      fetchMatchups: async (week) => {\n        const { currentLeague, currentWeek } = get();\n        if (!currentLeague) return;\n        \n        const targetWeek = week || currentWeek;\n        \n        try {\n          const matchups = await sleeperService.getMatchups(currentLeague.league_id, targetWeek);\n          set({ currentMatchups: matchups, currentWeek: targetWeek });\n        } catch (error: any) {\n          set({ error: error.message });\n        }\n      },\n      \n      // Fetch all NFL players\n      fetchPlayers: async () => {\n        try {\n          const playerMap = await sleeperService.getAllPlayers();\n          set({ players: playerMap });\n        } catch (error: any) {\n          console.error('Failed to fetch players:', error);\n          // Don't set error since this is background\n        }\n      },\n      \n      // Refresh all data\n      refreshData: async () => {\n        const { currentLeague, currentWeek } = get();\n        if (!currentLeague) return;\n        \n        set({ isLoading: true });\n        \n        try {\n          await Promise.all([\n            get().selectLeague(currentLeague.league_id),\n            get().fetchPlayers()\n          ]);\n        } catch (error: any) {\n          set({ error: error.message });\n        } finally {\n          set({ isLoading: false });\n        }\n      },\n      \n      // Optimize lineup based on projections/points\n      optimizeLineup: () => {\n        const { myRoster, currentLeague, players, currentMatchups } = get();\n        if (!myRoster || !currentLeague) return [];\n        \n        // Get current matchup for player points\n        const myMatchup = currentMatchups.find(m => m.roster_id === myRoster.roster_id);\n        const playerPoints = myMatchup?.players_points || {};\n        \n        // Convert players array to the format expected by the service\n        const rosterPlayers = myRoster.players\n          .map(playerId => players.get(playerId))\n          .filter(Boolean) as SleeperPlayer[];\n        \n        // Use the service's optimization function\n        return sleeperService.calculateOptimalLineup(\n          rosterPlayers,\n          playerPoints,\n          currentLeague.roster_positions\n        );\n      },\n      \n      // Logout and clear data\n      logout: () => {\n        set({\n          user: null,\n          leagues: [],\n          currentLeague: null,\n          rosters: [],\n          leagueUsers: new Map(),\n          myRoster: null,\n          currentMatchups: [],\n          currentWeek: 1,\n          isLoading: false,\n          error: null\n        });\n      }\n    }),\n    {\n      name: 'sleeper-store',\n      partialize: (state) => ({\n        user: state.user,\n        currentLeague: state.currentLeague,\n        currentWeek: state.currentWeek\n      })\n    }\n  )\n);\n\nexport default useSleeperStore;"],"names":[],"mappings":"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","ignoreList":[0,1,2]}